"""
AI Service for entity behavior processing.

Handles entity state machine updates, movement, aggro detection, and combat.
This service follows the service boundary rules:
- Only accesses GSM directly for entity data
- Uses other services for cross-domain data (players, maps, pathfinding)

Entity State Machine:
  IDLE -> (random 1-5 sec) -> WANDER
  WANDER -> (reached target or no path) -> IDLE
  IDLE/WANDER -> (player in aggro_radius + LOS) -> COMBAT
  COMBAT -> (target dead/logout OR disengage_radius OR LOS timeout 5s) -> RETURNING
  RETURNING -> (reached spawn + healed) -> IDLE
"""

import random
from dataclasses import dataclass
from typing import Dict, List, Optional, Set, Tuple, Any

from server.src.core.config import settings
from server.src.core.entities import EntityBehavior, EntityState, get_entity_by_name
from server.src.core.logging_config import get_logger
from server.src.core.monsters import MonsterDefinition
from server.src.services.game_state_manager import GameStateManager
from server.src.services.map_service import get_map_manager
from server.src.services.pathfinding_service import PathfindingService
from server.src.services.player_service import PlayerService
from server.src.services.entity_spawn_service import EntitySpawnService

logger = get_logger(__name__)


@dataclass
class EntityCombatEvent:
    """
    Combat event generated by entity AI for broadcasting to clients.
    
    Contains all information needed to broadcast an EVENT_COMBAT_ACTION message.
    """
    map_id: str
    attacker_id: int  # Entity instance_id
    attacker_name: str  # Entity display name
    defender_id: int  # Player ID
    defender_name: str  # Player username
    hit: bool
    damage: int
    defender_hp: int
    defender_died: bool
    message: str


class AIService:
    """
    Entity AI processing service.
    
    All methods are static to match the service pattern used elsewhere.
    Processes entity state machines each tick based on configured intervals.
    """
    
    # Per-entity timers stored in memory (not persisted to Valkey)
    # These are transient and reset on server restart
    # {instance_id: {"idle_timer": int, "wander_target": (x, y) or None, ...}}
    _entity_timers: Dict[int, Dict[str, Any]] = {}
    
    @staticmethod
    async def process_entities(
        gsm: GameStateManager,
        map_id: str,
        current_tick: int,
    ) -> List[EntityCombatEvent]:
        """
        Process all entities on a map for one tick.
        
        Called by the game loop every tick for each active map.
        
        Args:
            gsm: GameStateManager instance
            map_id: Map to process entities for
            current_tick: Current global tick counter
            
        Returns:
            List of combat events that occurred this tick, to be broadcast to clients.
        """
        combat_events: List[EntityCombatEvent] = []
        
        if not settings.ENTITY_AI_ENABLED:
            return combat_events
        
        # Get all entities on this map
        entities = await gsm.get_map_entities(map_id)
        if not entities:
            return combat_events
        
        # Get collision grid for pathfinding
        map_manager = get_map_manager()
        tile_map = map_manager.get_map(map_id)
        if not tile_map:
            return combat_events
        collision_grid = tile_map.get_collision_grid()
        
        # Get all entity positions for blocking (entities can't walk through each other)
        entity_positions = await EntitySpawnService.get_entity_positions(gsm, map_id)
        blocked_positions: Set[Tuple[int, int]] = set(entity_positions.values())
        
        # Get all players on this map for aggro checks
        players_on_map = await PlayerService.get_players_on_map(map_id)
        
        for entity in entities:
            try:
                combat_event = await AIService._process_single_entity(
                    gsm=gsm,
                    entity=entity,
                    collision_grid=collision_grid,
                    blocked_positions=blocked_positions,
                    players_on_map=players_on_map,
                    current_tick=current_tick,
                    map_id=map_id,
                )
                if combat_event:
                    combat_events.append(combat_event)
            except Exception as e:
                logger.error(
                    "Error processing entity AI",
                    extra={
                        "instance_id": entity.get("id"),
                        "entity_name": entity.get("entity_name"),
                        "error": str(e),
                    }
                )
        
        return combat_events
    
    @staticmethod
    async def _process_single_entity(
        gsm: GameStateManager,
        entity: Dict[str, Any],
        collision_grid: List[List[bool]],
        blocked_positions: Set[Tuple[int, int]],
        players_on_map: List[Dict[str, Any]],
        current_tick: int,
        map_id: str,
    ) -> Optional[EntityCombatEvent]:
        """
        Process AI for a single entity.
        
        Dispatches to state-specific handlers.
        
        Returns:
            EntityCombatEvent if an attack occurred, None otherwise.
        """
        instance_id = entity.get("id")
        state_str = entity.get("state", "idle")
        
        # Skip dead/dying entities
        if state_str in ("dead", "dying"):
            return None
        
        state = EntityState(state_str)
        
        # Get entity definition for behavior settings
        entity_name = entity.get("entity_name", "")
        entity_enum = get_entity_by_name(entity_name)
        if not entity_enum:
            return None
        
        entity_def = entity_enum.value
        behavior = entity_def.behavior
        
        # Skip non-AI behaviors (merchants, quest givers)
        if behavior in (EntityBehavior.MERCHANT, EntityBehavior.QUEST_GIVER):
            return None
        
        # Ensure entity has timer state
        if instance_id not in AIService._entity_timers:
            AIService._entity_timers[instance_id] = {
                "idle_timer": random.randint(
                    settings.ENTITY_AI_IDLE_MIN,
                    settings.ENTITY_AI_IDLE_MAX
                ),
                "wander_target": None,
                "last_move_tick": 0,
                "last_aggro_check_tick": 0,
                "last_attack_tick": 0,
            }
        
        timers = AIService._entity_timers[instance_id]
        
        # Check for aggro (for aggressive entities) periodically
        if behavior == EntityBehavior.AGGRESSIVE and state != EntityState.COMBAT:
            if current_tick - timers["last_aggro_check_tick"] >= settings.ENTITY_AI_AGGRO_CHECK_INTERVAL:
                timers["last_aggro_check_tick"] = current_tick
                
                aggro_target = await AIService._check_aggro(
                    entity=entity,
                    entity_def=entity_def,
                    players_on_map=players_on_map,
                    collision_grid=collision_grid,
                )
                
                if aggro_target:
                    # Enter combat
                    await gsm.set_entity_state(
                        instance_id=instance_id,
                        state=EntityState.COMBAT,
                        target_player_id=aggro_target["player_id"],
                    )
                    timers["wander_target"] = None
                    logger.debug(
                        "Entity entering combat",
                        extra={
                            "instance_id": instance_id,
                            "target_player_id": aggro_target["player_id"],
                        }
                    )
                    return None
        
        # Dispatch to state handler
        if state == EntityState.IDLE:
            await AIService._handle_idle_state(
                gsm=gsm,
                entity=entity,
                entity_def=entity_def,
                timers=timers,
                current_tick=current_tick,
            )
        elif state == EntityState.WANDER:
            await AIService._handle_wander_state(
                gsm=gsm,
                entity=entity,
                entity_def=entity_def,
                timers=timers,
                collision_grid=collision_grid,
                blocked_positions=blocked_positions,
                current_tick=current_tick,
            )
        elif state == EntityState.COMBAT:
            return await AIService._handle_combat_state(
                gsm=gsm,
                entity=entity,
                entity_def=entity_def,
                timers=timers,
                players_on_map=players_on_map,
                collision_grid=collision_grid,
                blocked_positions=blocked_positions,
                current_tick=current_tick,
                map_id=map_id,
            )
        elif state == EntityState.RETURNING:
            await AIService._handle_returning_state(
                gsm=gsm,
                entity=entity,
                entity_def=entity_def,
                timers=timers,
                collision_grid=collision_grid,
                blocked_positions=blocked_positions,
                current_tick=current_tick,
            )
        
        return None
    
    @staticmethod
    async def _check_aggro(
        entity: Dict[str, Any],
        entity_def: MonsterDefinition,
        players_on_map: List[Dict[str, Any]],
        collision_grid: List[List[bool]],
    ) -> Optional[Dict[str, Any]]:
        """
        Check if any player is within aggro range and has line of sight.
        
        Returns the closest valid target, or None if no target found.
        """
        entity_x = entity.get("x", 0)
        entity_y = entity.get("y", 0)
        entity_pos = (entity_x, entity_y)
        
        # Get aggro radius (use override if set, otherwise use definition)
        aggro_radius = entity.get("aggro_radius") or entity_def.aggro_radius
        if aggro_radius <= 0:
            return None
        
        closest_target = None
        closest_distance = float("inf")
        
        for player in players_on_map:
            player_x = player.get("x", 0)
            player_y = player.get("y", 0)
            player_pos = (player_x, player_y)
            
            # Check Manhattan distance
            distance = PathfindingService.manhattan_distance(entity_pos, player_pos)
            if distance > aggro_radius:
                continue
            
            # Check line of sight
            if not PathfindingService.has_line_of_sight(entity_pos, player_pos, collision_grid):
                continue
            
            # Valid target - track closest
            if distance < closest_distance:
                closest_distance = distance
                closest_target = player
        
        return closest_target
    
    @staticmethod
    async def _handle_idle_state(
        gsm: GameStateManager,
        entity: Dict[str, Any],
        entity_def: MonsterDefinition,
        timers: Dict[str, Any],
        current_tick: int,
    ) -> None:
        """
        Handle IDLE state: wait for random timer, then transition to WANDER.
        """
        instance_id = entity.get("id")
        wander_radius = entity.get("wander_radius", 0)
        
        # If no wander radius, stay idle forever
        if wander_radius <= 0:
            return
        
        # Decrement idle timer
        timers["idle_timer"] -= 1
        
        if timers["idle_timer"] <= 0:
            # Transition to wander
            await gsm.set_entity_state(instance_id, EntityState.WANDER)
            
            # Pick a random wander target within radius
            spawn_x = entity.get("spawn_x", entity.get("x", 0))
            spawn_y = entity.get("spawn_y", entity.get("y", 0))
            
            # Pick random offset within wander radius
            target_x = spawn_x + random.randint(-wander_radius, wander_radius)
            target_y = spawn_y + random.randint(-wander_radius, wander_radius)
            
            timers["wander_target"] = (target_x, target_y)
            timers["last_move_tick"] = current_tick
            
            logger.debug(
                "Entity starting wander",
                extra={
                    "instance_id": instance_id,
                    "target": (target_x, target_y),
                }
            )
    
    @staticmethod
    async def _handle_wander_state(
        gsm: GameStateManager,
        entity: Dict[str, Any],
        entity_def: MonsterDefinition,
        timers: Dict[str, Any],
        collision_grid: List[List[bool]],
        blocked_positions: Set[Tuple[int, int]],
        current_tick: int,
    ) -> None:
        """
        Handle WANDER state: move toward target, return to IDLE when reached.
        """
        instance_id = entity.get("id")
        
        # Check move interval
        if current_tick - timers["last_move_tick"] < settings.ENTITY_AI_WANDER_INTERVAL:
            return
        
        wander_target = timers.get("wander_target")
        if not wander_target:
            # No target, go back to idle
            await AIService._transition_to_idle(gsm, instance_id, timers)
            return
        
        entity_x = entity.get("x", 0)
        entity_y = entity.get("y", 0)
        current_pos = (entity_x, entity_y)
        
        # Check if reached target
        if current_pos == wander_target:
            await AIService._transition_to_idle(gsm, instance_id, timers)
            return
        
        # Remove self from blocked positions for pathfinding
        own_blocked = blocked_positions - {current_pos}
        
        # Get next step toward target
        next_step = PathfindingService.get_next_step(
            current=current_pos,
            target=wander_target,
            collision_grid=collision_grid,
            blocked_positions=own_blocked,
            max_distance=settings.ENTITY_AI_MAX_PATHFINDING_DISTANCE,
        )
        
        if next_step:
            # Move entity
            await gsm.update_entity_position(instance_id, next_step[0], next_step[1])
            timers["last_move_tick"] = current_tick
        else:
            # No path, give up and return to idle
            await AIService._transition_to_idle(gsm, instance_id, timers)
    
    @staticmethod
    async def _handle_combat_state(
        gsm: GameStateManager,
        entity: Dict[str, Any],
        entity_def: MonsterDefinition,
        timers: Dict[str, Any],
        players_on_map: List[Dict[str, Any]],
        collision_grid: List[List[bool]],
        blocked_positions: Set[Tuple[int, int]],
        current_tick: int,
        map_id: str,
    ) -> Optional[EntityCombatEvent]:
        """
        Handle COMBAT state: chase target, attack when in range.
        
        Transitions to RETURNING if:
        - Target logged out or died
        - Target is beyond disengage_radius from spawn
        - LOS lost for 5 seconds
        
        Returns:
            EntityCombatEvent if an attack occurred, None otherwise.
        """
        instance_id = entity.get("id")
        entity_x = entity.get("x", 0)
        entity_y = entity.get("y", 0)
        entity_pos = (entity_x, entity_y)
        spawn_x = entity.get("spawn_x", entity_x)
        spawn_y = entity.get("spawn_y", entity_y)
        spawn_pos = (spawn_x, spawn_y)
        
        target_player_id = entity.get("target_player_id")
        if not target_player_id:
            # No target, return to spawn
            await AIService._transition_to_returning(gsm, instance_id, timers)
            return None
        
        # Find target in players list
        target_player = None
        for player in players_on_map:
            if player.get("player_id") == target_player_id:
                target_player = player
                break
        
        if not target_player:
            # Target logged out or left map, return to spawn
            await AIService._transition_to_returning(gsm, instance_id, timers)
            return None
        
        target_x = target_player.get("x", 0)
        target_y = target_player.get("y", 0)
        target_pos = (target_x, target_y)
        
        # Check disengage distance (from spawn, not entity)
        disengage_radius = entity.get("disengage_radius") or entity_def.disengage_radius
        spawn_to_target = PathfindingService.manhattan_distance(spawn_pos, target_pos)
        
        if disengage_radius > 0 and spawn_to_target > disengage_radius:
            # Target too far from spawn, disengage
            logger.debug(
                "Entity disengaging - target too far from spawn",
                extra={
                    "instance_id": instance_id,
                    "distance": spawn_to_target,
                    "disengage_radius": disengage_radius,
                }
            )
            await AIService._transition_to_returning(gsm, instance_id, timers)
            return None
        
        # Check line of sight
        has_los = PathfindingService.has_line_of_sight(entity_pos, target_pos, collision_grid)
        
        los_lost_at_tick = entity.get("los_lost_at_tick")
        
        if not has_los:
            # LOS lost
            if los_lost_at_tick is None:
                # Just lost LOS, record when
                await gsm.set_entity_state(
                    instance_id=instance_id,
                    state=EntityState.COMBAT,
                    target_player_id=target_player_id,
                    los_lost_at_tick=current_tick,
                    los_lost_position_x=target_x,
                    los_lost_position_y=target_y,
                )
            else:
                # Check timeout
                ticks_without_los = current_tick - los_lost_at_tick
                if ticks_without_los >= settings.ENTITY_AI_LOS_TIMEOUT:
                    # LOS timeout, return to spawn
                    logger.debug(
                        "Entity disengaging - LOS timeout",
                        extra={"instance_id": instance_id}
                    )
                    await AIService._transition_to_returning(gsm, instance_id, timers)
                    return None
        else:
            # Has LOS - clear LOS tracking if it was set
            if los_lost_at_tick is not None:
                await gsm.set_entity_state(
                    instance_id=instance_id,
                    state=EntityState.COMBAT,
                    target_player_id=target_player_id,
                )
        
        # Calculate distance to target
        distance = PathfindingService.manhattan_distance(entity_pos, target_pos)
        
        # If adjacent (distance 1), attempt attack
        if distance <= 1:
            # Check attack cooldown
            if current_tick - timers["last_attack_tick"] >= settings.ENTITY_AI_ATTACK_INTERVAL:
                return await AIService._execute_entity_attack(
                    gsm=gsm,
                    entity=entity,
                    entity_def=entity_def,
                    target_player_id=target_player_id,
                    current_tick=current_tick,
                    timers=timers,
                    map_id=map_id,
                )
        else:
            # Need to chase - check chase interval
            if current_tick - timers["last_move_tick"] >= settings.ENTITY_AI_CHASE_INTERVAL:
                # Remove self from blocked positions
                own_blocked = blocked_positions - {entity_pos}
                
                # Get next step toward target
                next_step = PathfindingService.get_next_step(
                    current=entity_pos,
                    target=target_pos,
                    collision_grid=collision_grid,
                    blocked_positions=own_blocked,
                    max_distance=settings.ENTITY_AI_MAX_PATHFINDING_DISTANCE,
                )
                
                if next_step:
                    await gsm.update_entity_position(instance_id, next_step[0], next_step[1])
                    timers["last_move_tick"] = current_tick
        
        return None
    
    @staticmethod
    async def _handle_returning_state(
        gsm: GameStateManager,
        entity: Dict[str, Any],
        entity_def: MonsterDefinition,
        timers: Dict[str, Any],
        collision_grid: List[List[bool]],
        blocked_positions: Set[Tuple[int, int]],
        current_tick: int,
    ) -> None:
        """
        Handle RETURNING state: path back to spawn, heal to full.
        
        Transitions to IDLE when reached spawn.
        """
        instance_id = entity.get("id")
        entity_x = entity.get("x", 0)
        entity_y = entity.get("y", 0)
        entity_pos = (entity_x, entity_y)
        spawn_x = entity.get("spawn_x", entity_x)
        spawn_y = entity.get("spawn_y", entity_y)
        spawn_pos = (spawn_x, spawn_y)
        
        # Check if at spawn
        if entity_pos == spawn_pos:
            # Heal to full and return to idle
            max_hp = entity.get("max_hp", 10)
            await gsm.update_entity_hp(instance_id, max_hp)
            await AIService._transition_to_idle(gsm, instance_id, timers)
            return
        
        # Check move interval (use wander interval for returning)
        if current_tick - timers["last_move_tick"] < settings.ENTITY_AI_WANDER_INTERVAL:
            return
        
        # Remove self from blocked positions
        own_blocked = blocked_positions - {entity_pos}
        
        # Get next step toward spawn
        next_step = PathfindingService.get_next_step(
            current=entity_pos,
            target=spawn_pos,
            collision_grid=collision_grid,
            blocked_positions=own_blocked,
            max_distance=settings.ENTITY_AI_MAX_PATHFINDING_DISTANCE,
        )
        
        if next_step:
            await gsm.update_entity_position(instance_id, next_step[0], next_step[1])
            timers["last_move_tick"] = current_tick
        else:
            # Can't reach spawn (blocked), teleport to spawn
            logger.warning(
                "Entity teleporting to spawn - path blocked",
                extra={"instance_id": instance_id}
            )
            await gsm.update_entity_position(instance_id, spawn_x, spawn_y)
            max_hp = entity.get("max_hp", 10)
            await gsm.update_entity_hp(instance_id, max_hp)
            await AIService._transition_to_idle(gsm, instance_id, timers)
    
    @staticmethod
    async def _execute_entity_attack(
        gsm: GameStateManager,
        entity: Dict[str, Any],
        entity_def: MonsterDefinition,
        target_player_id: int,
        current_tick: int,
        timers: Dict[str, Any],
        map_id: str,
    ) -> Optional[EntityCombatEvent]:
        """
        Execute an entity's attack against a player.
        
        Uses CombatService for actual damage calculation.
        
        Returns:
            EntityCombatEvent if attack was successful, None otherwise.
            The caller should broadcast this event to clients on the map.
        """
        from server.src.services.combat_service import CombatService
        from common.src.protocol import CombatTargetType
        
        instance_id = entity.get("id")
        
        result = await CombatService.perform_attack(
            attacker_type=CombatTargetType.ENTITY,
            attacker_id=instance_id,
            defender_type=CombatTargetType.PLAYER,
            defender_id=target_player_id,
        )
        
        timers["last_attack_tick"] = current_tick
        
        if result.success:
            logger.debug(
                "Entity attack executed",
                extra={
                    "instance_id": instance_id,
                    "target_player_id": target_player_id,
                    "damage": result.damage,
                    "hit": result.hit,
                }
            )
            
            # If target died, clear combat and return
            if result.defender_died:
                await AIService._transition_to_returning(gsm, instance_id, timers)
            
            # Get player username for the combat event
            defender_name = await PlayerService.get_username_by_player_id(target_player_id)
            if not defender_name:
                defender_name = "Unknown"
            
            # Return combat event for broadcasting
            return EntityCombatEvent(
                map_id=map_id,
                attacker_id=instance_id,
                attacker_name=entity.get("display_name", "Unknown"),
                defender_id=target_player_id,
                defender_name=defender_name,
                hit=result.hit,
                damage=result.damage,
                defender_hp=result.defender_hp,
                defender_died=result.defender_died,
                message=result.message,
            )
        
        return None
    
    @staticmethod
    async def _transition_to_idle(
        gsm: GameStateManager,
        instance_id: int,
        timers: Dict[str, Any],
    ) -> None:
        """Transition entity to IDLE state with new random timer."""
        await gsm.set_entity_state(instance_id, EntityState.IDLE)
        timers["idle_timer"] = random.randint(
            settings.ENTITY_AI_IDLE_MIN,
            settings.ENTITY_AI_IDLE_MAX
        )
        timers["wander_target"] = None
    
    @staticmethod
    async def _transition_to_returning(
        gsm: GameStateManager,
        instance_id: int,
        timers: Dict[str, Any],
    ) -> None:
        """Transition entity to RETURNING state."""
        await gsm.set_entity_state(instance_id, EntityState.RETURNING)
        timers["wander_target"] = None
    
    @staticmethod
    def cleanup_entity_timers(instance_id: int) -> None:
        """
        Clean up timer state for an entity.
        
        Called when entity dies or despawns.
        """
        AIService._entity_timers.pop(instance_id, None)
    
    @staticmethod
    def reset_all_timers() -> None:
        """
        Reset all entity timer state.
        
        Called on server startup to clear stale state.
        """
        AIService._entity_timers.clear()
    
    @staticmethod
    async def clear_entities_targeting_player(
        gsm: GameStateManager,
        map_id: str,
        player_id: int,
    ) -> int:
        """
        Clear all entities targeting a specific player (e.g., when player dies).
        
        Entities targeting the dead player will transition to RETURNING state.
        
        Args:
            gsm: GameStateManager instance
            map_id: Map where the player died
            player_id: The player ID to clear from targets
            
        Returns:
            Number of entities that had their target cleared.
        """
        entities = await gsm.get_map_entities(map_id)
        cleared_count = 0
        
        for entity in entities:
            target_player_id = entity.get("target_player_id")
            if target_player_id == player_id:
                instance_id = entity.get("id")
                if instance_id:
                    # Transition entity to RETURNING state
                    await gsm.set_entity_state(
                        instance_id=instance_id,
                        state=EntityState.RETURNING,
                    )
                    
                    # Clear wander target in timer state
                    if instance_id in AIService._entity_timers:
                        AIService._entity_timers[instance_id]["wander_target"] = None
                    
                    cleared_count += 1
                    logger.debug(
                        "Cleared entity target - player died",
                        extra={
                            "instance_id": instance_id,
                            "player_id": player_id,
                        }
                    )
        
        return cleared_count
